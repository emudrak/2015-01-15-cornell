```{r, echo=FALSE}
knitr::opts_chunk$set(results='hide')
```
# Analyzing Multiple Data Sets

We have created a function called analyze that creates graphs of the minimum, average, and maximum daily inflammation rates for a single data set:

```{r}
analyze <- function(filename) {
	data <- read.csv(filename)
		
	avg_day_inflammation <- apply(data, 2, mean)
	max_day_inflammation <- apply(data, 2, max)
	min_day_inflammation <- apply(data, 2, min)
  
  par(mfrow=c(1,3))
  plot(avg_day_inflammation, type="l")
  plot(max_day_inflammation, type="l")
  plot(min_day_inflammation, type="l")
}
```

We can use it to analyze other data sets one by one:

```{r, eval=FALSE}
analyze('data/inflammation-01.csv')
analyze('data/inflammation-02.csv')
```

```{r echo=FALSE}
analyze("../../data/inflammation/inflammation-01.csv")
analyze("../../data/inflammation/inflammation-02.csv")
```





but we have a dozen data sets right now and more on the way. We want to create plots for all our data sets with a single statement. To do that, we'll have to teach the computer how to repeat things.

## Objectives

* Explain what a `for` loop does.
* Correctly write for loops to repeat simple calculations.
* Trace changes to a loop variable as the loop runs.
* Trace changes to other variables as they are updated by a for loop.
* Explain what a list is.
* Create and index lists of simple values.
* Use a library function to get a list of filenames that match a simple wildcard pattern.
* Use a for loop to process multiple files.

## For Loops
 The general form of a loop is:

```{r, eval=FALSE}
for (variable in collection){
	do things with variable
}
```

We can call the loop variable anything we like, but there must be a curly brace `{` at the end of the line starting the loop, and we should indent the body of the loop.

Here is a loop that prints out the squares of a set of numbers

```{r }

for (i in 1:10){
  sq <- i^2
  print(paste("The square of ", i, "is", sq))
}

```

Here's another loop that repeatedly updates a variable:

```{r}
len = 0
for (vowel in 1:nchar('aeiou')){
    len = len + 1
	print(paste('There are', len, 'vowels'))
}
```

It's worth tracing the execution of this little program step by step. Since there are five characters in 'aeiou', the `print` statement will be executed five times. The first time around, length is zero (the value assigned to it on line 1) and vowel is 'a'. The statement adds 1 to the old value of length, producing 1, and updates length to refer to that new value. The next time around, vowel is 'e' and length is 1, so length is updated to be 2. After three more updates, length is 5; since there is nothing left in 'aeiou' for R to process, the loop finishes and the `print` statement tells us our final answer.


### Challenges

1. R has a built-in function called `seq` that creates a list of numbers: `seq(3)` produces `[1] 1, 2, 3`, `seq(2, 5)` produces [1] 2, 3, 4, 5, and `seq(2, 10, 3)` produces `[1] 2, 5, 8`. Using `seq`, write a function that prints the _n_ natural numbers:
	
```{r}
print_numbers <- function(N) {
	nseq <- seq(N)
	for (i in 1:length(nseq)) {
		print(nseq[i])
	}
}
```

2. Exponentiation is built into R: `2**4`. Write a function called expo that uses a loop to calculate the same result. Make the form be: `expo(base, power)`

```{r }


expo <- function(base, power){
  result <- 1
  for (i in 1:power){
    result <- result*base
  }
  return(result)
  
}
```


# Processing Multiple Files

We now have almost everything we need to process all our data files. 

What we need is a function that finds files whose names match a pattern. We provide those patterns as strings: the character * matches zero or more characters, while ? matches any one character. We can use this to get the names of all the R files we have created so far:

```{r}
list.files(pattern = "*.R")
```

or to get the names of all our CSV data files:

```{r, eval=FALSE}
filenames <- list.files(pattern="*.csv", recursive = TRUE)
filenames
```

```{r, echo=FALSE, results="show"}
filenames <- list.files(path="../../data/inflammation/", pattern="*.csv", recursive = TRUE)
filenames
```


As these examples show, `list.files()` result is a list of strings, which means we can loop over it to do something with each filename in turn. In our case, the "something" we want is our analyze function. Let's test it by analyzing the first three files in the list:

```{r}
filenames <- filenames[1:3]

for (f in 1:length(filenames)){
	print (filenames[f])
	analyze(filenames[f])
}
```

Sure enough, the maxima of these data sets show exactly the same ramp as the first, and their minima show the same staircase structure.

### Challenges

1. Write a function called `analyze_all` that takes a filename pattern as its sole argument and runs analyze for each file whose name matches the pattern.

## Key Points

* Use `for variable in collection` to process the elements of a collection one at a time.
* The body of a for loop does not have to, but should be indented.
* Use `length(thing)` to determine the length of something that contains other values.
* c(value1, value2, value3, â€¦) creates a vector
* Vectors are indexed and sliced in the same way as strings and arrays.
* vectors are mutable (i.e., their values can be changed in place).
* Use `list.files(pattern)` to create a list of files whose names match a pattern.
* Use `*` in a pattern to match zero or more characters.


## Next Steps

We have now solved our original problem: we can analyze any number of data files with a single command. More importantly, we have met two of the most important ideas in programming:

* Use functions to make code easier to re-use and easier to understand.
* Use vectors and arrays to store related values, and loops to repeat operations on them.

We have one more big idea to introduce...