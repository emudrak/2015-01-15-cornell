---
layout: topic
title: Loops
minutes: 60
---

## Inflammation Data

The rest of the lessons about functions and analyzing multiple data sets will use a new data set about inflammation. 

Say we are studying inflammation in patients who have been given a new treatment for arthritis, and need to analyze the first dozen data sets.

The files are stored in a .zip file [here](http://emudrak.github.io/2015-01-15-cornell/data/biology/inflammation.zip). Download it into your `/data` directory and unzip it. 

## PAUSE ##
Make sure everyone has downloaded the zip file. 
 
The data sets are stored in comma-separated values (CSV) format: each row holds information for a single patient, and the columns represent successive days. 
The first few rows of our first file look like this:

```{r echo = FALSE}
tmp <- read.csv("../../data/inflammation/inflammation-01.csv", header = FALSE, nrows = 5)
write.table(tmp, quote = FALSE, sep = ",", row.names = FALSE, col.names = FALSE)
rm(tmp)
```

For each data set, we want to:

* calculate the average inflammation per day across all patients, and
* plot the result.

To do all that, we'll have to learn a little bit about programming.  But first, let's make an analysis plan for the first file.

Load the first data file into R using `read.csv`:

```{r, echo=FALSE }
dat <- read.csv(file="../../data/inflammation/inflammation-01.csv")
```


```{r, results="hide", eval=FALSE}
dat <- read.csv(file = "inflammation-01.csv", header = FALSE)

head(dat)
```

#### Challenge

* What class is this data?
* How many patients (rows) does this data contain?
* How many days (columns) do we have data for? 
* What is the inflammation level for patients 30 at day 20? 


```{r answers, echo=FALSE}
class(dat)
nrow(dat)
ncol(dat)
dim(dat)
dat[30, 20]

```

Now let's perform some common mathematical operations to learn about our inflammation data.

## Challenge

* What is the minimum inflammation on day 7? 
* What is the mean inflammation on day 12? 
* What is the maximum inflammation for patient 5


```{r, echo=FALSE, results="hide"}
# minimum inflammation on day 7
min(dat[, 7])
# mean inflammation on day 7
mean(dat[, 12])
# max inflammation for patient 5
max(dat[5, ])

```

What if we need the maximum inflammation for all patients, or the average for each day?

To support this, we can use the `apply` function.

`apply` allows us to repeat a function on all of the rows (`MARGIN = 1`) or columns (`MARGIN = 2`) of a data frame.

Thus, to obtain the average inflammation of each patient we will need to calculate the mean of all of the rows (`MARGIN = 1`) of the data frame.

```{r}
avg_patient_inflammation <- apply(dat, 1, mean)
```

And to obtain the average inflammation of each day we will need to calculate the mean of all of the columns (`MARGIN = 2`) of the data frame.

```{r}
avg_day_inflammation <- apply(dat, 2, mean)
```

Since the second argument to `apply` is `MARGIN`, the above command is equivalent to `apply(dat, MARGIN = 2, mean)`.
We'll learn why this is so in the next lesson.

> **Tip:** Some common operations have more efficient alternatives.
For example, you can calculate the row-wise or column-wise means with `rowMeans` and `colMeans`, respectively.

### Plotting

Let's take a look at the average inflammation over time.
Recall that we already saved them in the variable `avg_day_inflammation`.
Plotting the values is done with the function `plot`.

```{r plot-avg-inflammation, fig.height=4, fig.width=4}
plot(avg_day_inflammation)
plot(avg_day_inflammation, type="l")
```

Above, we gave the function `plot` a vector of numbers corresponding to the average inflammation per day across all patients.
`plot` created a scatter plot where the y-axis is the average inflammation level and the x-axis is the order, or index, of the values in the vector, which in this case correspond to the 40 days of treatment.


Let's have a look at two other statistics: the maximum and minimum inflammation per day.

```{r plot-max-inflammation, fig.height=4, fig.width=4}
max_day_inflammation <- apply(dat, 2, max)
plot(max_day_inflammation, type="l")
```

```{r plot-min-inflammation, fig.height=4, fig.width=4}
min_day_inflammation <- apply(dat, 2, min)
plot(min_day_inflammation, type="l")
```


*Note* you can show all of these plots together by modifying some R graphics parameters.  This is done with the command `par()`.  Look at the help file for this function either by typing it in the search window, or by typing `?par()`.  There are many, many parameters that can be adjusted here.  

```{r, warning=FALSE}
par(mfrow=c(1,3))
plot(avg_day_inflammation, type="l")
plot(max_day_inflammation, type="l")
plot(min_day_inflammation, type="l")
par(mfrow=c(1,1)) #reset to original
```


#### Next Steps

We have successfully plotted the avg, max and minimum inflammation per day for the first file.  We would like to do the same for the other 11 the same way, but typing in the same commands repeatedly is tedious and error-prone.

### Challenges

This next challenge has several steps. Think about how you break down a difficult problem into manageable pieces.

1. Write a function called `analyze` that takes a filename as a parameter and displays the 3 graphs you made earlier (average, min and max inflammation over time). i.e., `analyze('data/inflammation-01.csv')` should produce the graphs already shown, while `analyze('inflammation-02.csv')` should produce corresponding graphs for the second data set. Be sure to give your function a docstring.

```{r}

analyze <- function(filename){
  # x is a file name for a data frame of numbers
  # This function reads the csv file with inflammation data, calculates the mean, max and min inflmmation values across patients for each day, and then plots it side by side
  dat <- read.csv(file = filename, header = FALSE)
  avg_day_inflammation <- apply(dat, 2, mean)
  max_day_inflammation <- apply(dat, 2, max)
  min_day_inflammation <- apply(dat, 2, min)
  
  par(mfrow=c(1,3))
  plot(avg_day_inflammation, type="l")
  plot(max_day_inflammation, type="l")
  plot(min_day_inflammation, type="l")

}


```

Try it out: 

```{r, fig.height=4 }

analyze("../../data/inflammation/inflammation-01.csv")
analyze("../../data/inflammation/inflammation-02.csv")
analyze("../../data/inflammation/inflammation-03.csv")
analyze("../../data/inflammation/inflammation-04.csv")
```


## Next Steps

We now have a function called analyze to visualize a single data set. We could use it to explore all 12 of our current data sets like this:

```{r, eval=FALSE}
# analyze('data/inflammation-01.csv')
# analyze('data/inflammation-02.csv')
# #...
# analyze('data/inflammation-12.csv')
```

but the chances of us typing all 12 filenames correctly aren't great, and we'll be even worse off if we get another hundred files. What we need is a way to tell R to do something once for each file, and that will be the subject of the next lesson.


# Analyzing Multiple Data Sets

## Objectives

* Explain what a `for` loop does.
* Correctly write for loops to repeat simple calculations.
* Trace changes to a loop variable as the loop runs.
* Trace changes to other variables as they are updated by a for loop.
* Explain what a list is.
* Create and index lists of simple values.
* Use a library function to get a list of filenames that match a simple wildcard pattern.
* Use a for loop to process multiple files.

## For Loops
 The general form of a loop is:

```{r, eval=FALSE}
for (variable in collection){
	do things with variable
}
```

We can call the loop variable anything we like, but there must be a curly brace `{` at the end of the line starting the loop, and we should indent the body of the loop.

Here is a loop that prints out the squares of a set of numbers

```{r }

for (i in 1:10){
  sq <- i^2
  print(paste("The square of ", i, "is", sq))
}

```


It's worth tracing the execution of this little program step by step. Since there are 10 instances in the sequence `1:10`, the indexing variable `i` gets assigned to each of those values in turn. Each time, a variable `sq` is evaluated   The first time around, length is zero (the value assigned to it on line 1) and vowel is 'a'. The statement adds 1 to the old value of length, producing 1, and updates length to refer to that new value. The next time around, vowel is 'e' and length is 1, so length is updated to be 2. After three more updates, length is 5; since there is nothing left in 'aeiou' for R to process, the loop finishes and the `print` statement tells us our final answer.


### Challenges

1. Exponentiation is built into R: `2**4`. Write a function called expo that uses a loop to calculate the same result. Make the form be: `expo(base, power)`

```{r }


expo <- function(base, power){
  result <- 1
  for (i in 1:power){
    result <- result*base
  }
  return(result)
  
}
```


# Processing Multiple Files

We now have almost everything we need to process all our data files. We need a way to be able to specify the collection that the for loop with operate over. 

What we need is a function that finds files whose names match a pattern. We provide those patterns as strings: the character * matches zero or more characters, while ? matches any one character. We can use this to get the names of all the R files we have created so far:

```{r}
list.files(pattern = "*.R")
```

or to get the names of all our CSV data files:

```{r, eval=FALSE}
filenames <- list.files(pattern="*.csv", recursive = TRUE)
filenames
```

```{r, echo=FALSE, results="show"}
filenames <- list.files(path="../../data/inflammation/", pattern="*.csv", recursive = TRUE, full.names=TRUE)
filenames
```


As these examples show, `list.files()` result is a list of strings, which means we can loop over it to do something with each filename in turn. In our case, the "something" we want is our analyze function. Let's test it by analyzing the first three files in the list:

```{r}
filenames <- filenames[1:3]

for (f in 1:length(filenames)){
	print (filenames[f])
	analyze(filenames[f])
}

```



### Challenges

1. Write a function called `analyze_all` that takes a filename pattern as its sole argument and runs analyze for each file whose name matches the pattern.

## Key Points

* Use `for variable in collection` to process the elements of a collection one at a time.
* The body of a for loop does not have to, but should be indented.
* Use `length(thing)` to determine the length of something that contains other values.
* c(value1, value2, value3, …) creates a vector
* Vectors are indexed and sliced in the same way as strings and arrays.
* vectors are mutable (i.e., their values can be changed in place).
* Use `list.files(pattern)` to create a list of files whose names match a pattern.
* Use `*` in a pattern to match zero or more characters.


## Next Steps

We have now solved our original problem: we can analyze any number of data files with a single command. More importantly, we have met two of the most important ideas in programming:

* Use functions to make code easier to re-use and easier to understand.
* Use vectors and arrays to store related values, and loops to repeat operations on them.



