---
layout: topic
title: The data.frame class
minutes: 30
---

```{r, echo=FALSE, purl=FALSE, comment=NA}
knitr::opts_chunk$set(results='hide', fig.path='img/r-lesson')
surveys <- read.csv(file="../../data/biology/surveys.csv")
```



> ## Learning Objectives
>
> * understand the concept of a `data.frame`
> * know how to access any element or section of a `data.frame`
> * use sequences



# Indexing and sequences

```{r, echo=FALSE, purl=TRUE}
## Indexing and sequences
```

If we want to extract one or several values from a vector, we must provide one
or several indices in square brackets, just as we do in math. For instance:

```{r, results='show', purl=FALSE}
animals <- c("mouse", "rat", "dog", "cat")
animals[2]
animals[c(3, 2)]
animals[2:4]
more_animals <- animals[c(1:3, 2:4)]
more_animals
```

Show everything except a certain index by using the minus sign

```{r, results='show', purl=FALSE}
animals[-1]
animals[c(-2,-4)]

```




R indexes start at 1. Programming languages like Fortran, MATLAB, and R start
counting at 1, because that's what human beings typically do. Languages in the C
family (including C++, Java, Perl, and Python) count from 0 because that's
simpler for computers to do.

`:` is a special function that creates numeric vectors of integer in increasing
or decreasing order, test `1:10` and `10:1` for instance. The function `seq()`
(for __seq__uence) can be used to create more complex patterns:

```{r, results='show', purl=FALSE}
seq(1, 10, by=2)
seq(5, 10, length.out=3)
seq(50, by=5, length.out=10)
seq(1, 8, by=3) # sequence stops to stay below upper limit
```

Our survey data frame has rows and columns (it has 2 dimensions), if we want to
extract some specific data from it, we need to specify the "coordinates" we want
from it. Row numbers come first, followed by column numbers.

```{r, purl=FALSE}
surveys[1, 1]   # first element in the first column of the data frame
surveys[1, 6]   # first element in the 6th column
surveys[1:3, 7] # first three elements in the 7th column
surveys[1:3, 4:7] # first three elements in the 4th through 7th columns
surveys[3, ]    # the 3rd element for all columns
surveys[, 8]    # the entire 8th column
```

### Challenge

1. The function `nrow()` on a `data.frame` returns the number of rows. Use it,
   in conjuction with `seq()` to create a new `data.frame` called
   `surveys_by_10` that includes every 10th row of the survey data frame
   starting at row 10 (10, 20, 30, ...)

```{r, echo=FALSE, purl=TRUE}
### The function `nrow()` on a `data.frame` returns the number of
### rows. Use it, in conjuction with `seq()` to create a new
### `data.frame` called `surveys_by_10` that includes every 10th row
### of the survey data frame starting at row 10 (10, 20, 30, ...)
```

<!---
```{r, purl=FALSE}
surveys_by_10 <- surveys[seq(10, nrow(surveys), by=10), ]
```
--->

#Manipulating Data
> ## Learning Objectives
>
> * being able to subset for a level
> * being able to extract particular values from a `data.frame`
> * being able to add/remove columns and rows


# Subsetting data
In particular for larger datasets, it can be tricky to remember the column
number that corresponds to a particular variable. (Are species names in column 5
or 7? oh, right... they are in column 6). In some cases, in which column the
variable will be can change if the script you are using adds or removes
columns. It's therefore often better to use column names to refer to a
particular variable, and it makes your code easier to read and your intentions
clearer.

You can do operations on a particular column, by selecting it using the `$`
sign. In this case, the entire column is a vector. For instance, to extract all
the weights from our datasets, we can use: `surveys$wgt`. You can use
`names(surveys)` or `colnames(surveys)` to remind yourself of the column names.

In some cases, you may way to select more than one column. You can do this using
the square brackets: `surveys[, c("wgt", "sex")]`.

When analyzing data, though, we often want to look at partial statistics, such
as the maximum value of a variable per species or the average value per plot.

One way to do this is to select the data we want, and create a new temporary
array, using the `subset()` function. For instance, if we just want to look at
the animals of the species "DO":

```{r, purl=FALSE}
surveys_DO <- subset(surveys, species == "DO")
```

`subset()` is a function in "base R" which means that it comes automatically when you install R. Functions in R have a name, and then take arguments in parentheses. Type  `?subset` to call up the help for the subset function. You'll see some examples of useage, and then you'll see a listing of Arguments that `subset()` can take.  

The first argument, `x` is the object to be subsetted, in our case the data frame `surveys`. The second is `subset`, which the help tells us is a logical expression.  We put in here `species=="DO"`, which is a condition that tests for the column `species` to be equal to "DO." The third argument is `select`, which tells the columns to select from the data frame. If we leave it blank, the function will return all columns. 

In R, a test for "equals"" is two equal signs, because we use a single equal sign for assignment sometimes. Here are some other operators that R uses: 

|Operator  |  Description|
:---------:|---------------
|<          |less than
|<= 	     |less than or equal to
|> 	       |greater than
|>= 	     |greater than or equal to
|== 	     |exactly equal to
|!= 	     |not equal to
|!x 	     |Not x
|x \| y    |	x OR y
|x & y 	   |x AND y
|isTRUE(x) |test if X is TRUE 

### Challenge

1. Use subset() to print data collected since 1990. 
2. How many animals were male and of species "PE"?
3. How many individuals of the species "DM" or "SS"?
4. What value is returned by `surveys_DO$month[2]` (guess before you execute!)



```{r, echo=FALSE, purl=TRUE, results='hide'}
  subset(surveys, year>1990)
  nrow(subset(surveys, sex=="M" & species=="PE"))
  nrow(subset(surveys, species=="DM" | species=="SS"))
  surveys$month[2]

```

## Adding a column to our dataset

Sometimes, you may have to add a new column to your dataset that represents a
new variable. The easiest way to do this is to use the `$` symbol before a column name that doesn't exist yet
```{r add new column}
surveys$logwgt <- log(surveys$wgt)

```
Look at the data set now (use the grid icon in the Environment tab). There is a new column, and the values are equal to the log of the values in the wgt column. 

If you assign values to a column that doesn't exist yet, R will create a new column with those values. **Careful:**  If you had typed `surveys$wgt <- log(surveys$wgt)` you would have overwritted the original column. 


Look at the data frame structure again: 

```{r}
str(surveys)
```

The type for "plot" is integer. But the plots could have been labeled with a lettering scheme rather than numbers.  Here, plot is just a label, and the concept that plot 4 is twice that of plot 2 is false. So we should really make it a factor. 

```{r}
surveys$plot <- as.factor(surveys$plot)
```

Look at the structure of `surveys`. Now, plot is a factor with 24 levels. To us, that line of code changed the data type from `int` to `Factor. 

What actually happened was that R evaluated the code on the right of the ` <- ` (in this case, creating factors of the integers in the plot column), and assigned that value to the object on the left of the ` <- `, whcih already existed, so it overwrote the values.  That is ok in this case. 

## Removing columns

Just like you can select columns by their positions in the `data.frame` or by
their names, you can remove them similarly.

To remove it by column number:

```{r, results='show', purl=FALSE}
surveys_noDate <- surveys[, -c(2:4)]
colnames(surveys)
colnames(surveys_noDate)
```

The easiest way to remove by name is to use the `subset()` function. This time
we need to specify explicitly the argument `select` as the default is to subset
on rows (as above). The minus sign indicates the names of the columns to remove
(note that the column names should not be quoted):

```{r, results='show', purl=FALSE}
surveys_noDate2 <- subset(surveys, select=-c(month, day, year))
colnames(surveys_noDate2)
```

## Removing rows

Typically rows are not associated with names, so to remove them from the
`data.frame`, you can do:

```{r, results='show', purl=FALSE}
surveys_missingRows <- surveys[-c(10, 50:70), ] # removing rows 10, and 50 to 70
```


<!----
# Building data frames from existing ones  Skip?? 

You can stack data frames next to each other using `cbind()` (__c__olumn __bind__) and on top of each other using `rbind` (__r__ow __bind__).

To illustrate this, let's use some smaller data frames.  You can create data frames directly in R

```{r}

land_animals <- data.frame(animal=c("dog", "cat", "bunny", "snake"),
                           feel=c("furry", "furry", "fluffy", "smooth"),
                           weight=c(45, 8, 5.5, 1.2))
                           
sea_animals <- data.frame(animal=c("fish", "sea cucumber", "sea urchin"),
                           feel=c("smooth", "squishy", "spiny"),
                           weight=c( 8, 1.1, 0.8))

more_info <- data.frame(legs=c(4,4,4,0,0,0,0), eyes=c(2,2,2,2,2,0,0))

```

```{r, results="show"}

land_animals
sea_animals
more_info

```


With `rbind()` the number of columns and their names must be identical between the two objects:
```{r rbind}
all_animals <- rbind(land_animals, sea_animals)
all_animals
```

If not, you get an error: 
```{r, error=TRUE}

rbind(land_animals, more_info)

```


With `cbind()` additional columns must have the same number
of elements as there are rows in the `data.frame`.

```{r }
all_animals <- cbind(all_animals, more_info)
all_animals
```

####TALK ABOUT RECYCLING???
**Danger** if you don't have matching number of rows when doing cbind, R tries to "recycle" if the length of the longer object is a multiple of the shorter one.   Here, we try to cbind `sea_animals` (with 3 elements) with more_info with the first row removed so it has 6 elements.  Since 6 is a multiple of 3, R will recycle values in a way to make it "work out:"
```{r}

cbind(sea_animals, more_info[-1,])

```

So R wrote out the `sea_animals` twice to allow all 6 elements of `more_info` to fit in the data.frame.  This could be very bad if you're not aware of it. 

If the longer object is *not* a multiple of the shorter one, R will return an error: 

```{r, error=TRUE}

cbind(land_animals, more_info)

```

 --->



