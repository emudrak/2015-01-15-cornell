---
title: "Motivation for Log Transform Function"
author: "Erika Mudrak"
date: "Tuesday, January 13, 2015"
output: ioslides_presentation
---

## Common statistical Problem: 
  Your data is non-normal, and you need to make it normal for statistical analysis. 
Often, people turn to log-transform. 

```{r, echo=FALSE, fig.height=5}
set.seed(25)
zerodat<-round(rlnorm(50, log(3.5),1.2), 4)-1
zerodat[zerodat<0]<-0

zerodat <- sort(zerodat)

par(mfrow=c(2,1), mar=c(5,4,0.5,2))
hist(zerodat, breaks=10, main=NA)
hist(log(zerodat), breaks=10, main=NA)
nonzerodat <- zerodat[zerodat>0]
```

## But:
your data has some zeros, which are undefined after a log tranform: 


```{r, echo=FALSE, comment=NA}
cbind(data=zerodat, logdata=log(zerodat))[1:20,]
```

##
A common solution is to add one to the data. 

```{r, echo=FALSE, comment=NA, fig.height=4}
par(mfrow=c(1,2), mar=c(5,4,0.5,2))
plot(zerodat,log(zerodat))
points(nonzerodat[1],log(nonzerodat[1]), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]), col="green", pch=16)
plot(zerodat,log(zerodat+1))
points(0,log(1), col="red", pch="*", cex=3)
points(nonzerodat[1],log(nonzerodat[1]+1), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]+1), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]+1), col="green", pch=16)

zerodat[1:15]
```


 Maybe adding 1 is too much in this case.  
 
##
Perhaps something smaller?  Try 0.01. 
```{r, echo=FALSE, fig.height=4}

#Maybe adding 1 is too much. Add something smaller?
add=0.01
par(mfrow=c(1,2), mar=c(5,4,0.5,2))
plot(zerodat,log(zerodat), ylim=c(log(min(nonzerodat)), log(max(zerodat)+add)))
points(nonzerodat[1],log(nonzerodat[1]), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]), col="green", pch=16)

plot(zerodat,log(zerodat+add), ylim=c(log(add), log(max(zerodat)+add)), ylab=paste("log(zerodat) +", add))
points(0,log(add), col="red", pch="*", cex=3)
points(nonzerodat[1],log(nonzerodat[1]+add), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]+add), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]+add), col="green", pch=16)

```

##
Add something even smaller-  half the smallest non-zero value. 

```{r, echo=FALSE, fig.height=4}

add=0.001
par(mfrow=c(1,2), mar=c(5,4,0.5,2))
plot(zerodat,log(zerodat), ylim=c(log(min(nonzerodat)), log(max(zerodat)+add)))
points(nonzerodat[1],log(nonzerodat[1]), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]), col="green", pch=16)

plot(zerodat,log(zerodat+add), ylim=c(log(add), log(max(zerodat)+add)), ylab=paste("log(zerodat) +", add))
points(0,log(add), col="red", pch="*", cex=3)
points(nonzerodat[1],log(nonzerodat[1]+add), col="blue", pch=16)
points(nonzerodat[2],log(nonzerodat[2]+add), col="orange", pch=16)
points(nonzerodat[3],log(nonzerodat[3]+add), col="green", pch=16)
```


##
How to determine the correct small value to add? 

McCune and Grace 2002 (Chapt 9) suggest this method to figured out a small value that

1. Preserves original orders of magnitude in the data
1. Results in values of zero when initial value is zero. 

Given

- Min(x) is the smallest nonzero value in the data
- Int(x) is a function that truncates x to an integer by dropping digits after the decimal point
- c = order of magnitude constant = Int(log(Min(x))
- d = decimal constant = log-1 (c) 
                                        
then the transformation is 

**b = log(x + d) - c**


##
**b = log(x + d) - c**
```{r, echo=FALSE}
c <- floor(log(min(zerodat[zerodat!=0])))
d <- exp(c)
transf <- log(zerodat+d) - c
                                      
```
       
In this case, 

c= `r c`

d= `r d`
```{r, echo=FALSE, fig.height=4}
par(mfrow=c(1,2), mar=c(3,3,3,3))
plot(zerodat,log(zerodat), ylim=c(log(min(nonzerodat)), log(max(zerodat)+add)))
points(zerodat[13],log(zerodat[13]), col="blue", pch=16)
points(zerodat[14],log(zerodat[14]), col="orange", pch=16)
points(zerodat[15],log(zerodat[15]), col="green", pch=16)
                                        
plot(zerodat,transf)
points(0,transf[1], col="red", pch=8)
points(zerodat[13],transf[13], col="blue", pch=16)
points(zerodat[14],transf[14], col="orange", pch=16)
points(zerodat[15],transf[15], col="green", pch=16)
```       
       
